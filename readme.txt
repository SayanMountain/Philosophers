#1 https://www.youtube.com/watch?v=2sv8LB0_uKg
Многопоточность нужна для:
1 - на примере программы из строки

? Современные процессоры имеют несколько ядер


- Запуск исполняемого файла активизирует выполнение процесса.
- Активация процесса запускает минимум 1 поток, и имеет одну точку входа
int main

Тут интересный переход
    Что можно сделать, чтобы ускорить работу нашего процесса?
    Ответ - запустить еще один поток

Процесс это
    ййй
Поток это
    ййй




Что нам дает pthread?
    Это дает нам возможность запуска множества потоков

Как работает pthread_create?
    pthread_create(&t1, NULL, print, (void *)str1);
    где:
    t1 - указатель на идентификатор потока (проще поток)
    NULL - атрибуты
    print - запускаемая функция в потоке
    (void *)str1) - аргументы, которая функция принимает

Чем отличия от обычного исполнения кода?
    идет построково, код увидел функцию ушел в нее, завершил, вернулся в main
    когда мы используем многопоточность наш код не останавливается

Что необходимо использовать, дабы долждаться выполнения запущенного потока?
    pthread_join (t1, NULL)
    где:
    t1 указатель на идентификатор потока
    NULL - атрибуты
    Иными словами pthread_join является ограничителем, который не позволяет программе
    исполняться, до тех пор пока поток незавершен

Cоответсвенно, когда мы создали поток мы можем пойти лишь двумя способами:
    1 дождаться его завершения использовав pthread_join
    2 pthread_exit (выходит из какого-то потока сразу)


Как освободить ресурсы, которые задействоал поток?
    нужно использовать pthread_detach(t2);
    и запукать нужно внутри потока, чьи ресурсы требуется освободить


Тиакм образом, можно поток:
    - дождаться и завершить pthread_join
    - прекратить с высвобождением ресурсов pthread_detach

1 запрещены ли глобальные переменные?
2


!4 ВОПРОС Что такое mutex?
    mutex блокирует доступ к ресурсу другим потокам
    Обладает двумя состояниями (заблок и разблок)
    Это, по сути, наши вилки

    mutex надо накладывать на те участки кода, которые
    необходимо заблокировать после чего разблокировать


5 Deadlock
    дедлок ситуация, когда все философы схватили вилки вне очереди


6 Semaphor
    У каждого философа может быть свой семфор
    Может быть общий семафор на всех философов, который говорит, что можно ли есть или нет
    Если какой-то философов умер, то семафор останавливается и все вслед за ним (вошли в ожидание)
    После этого надо сделать kill


- мы не контролируем скорость запуска потока
- мы создали и запускаем потоки по очереди
- через ulseep (мы будем реализовывать, сколько он будет есть, пить и пр)
  надо модифицировать
-

Создаю массив из философов
Придаю их структуре порядок


if (philo_num % 2 == 0)
{
    pthread_mutex_lock(&mutex(philo_num) && pthread_mutex_lock(&mutex(philo_num - 1)
    eat_meat;
    pthread_mutex_unlock(&mutex(philo_num) && pthread_mutex_unlock(&mutex(philo_num - 1)
}
else
    pthread_mutex_lock(&mutex(philo_num) && pthread_mutex_lock(&mutex(philo_num - 1)
    eat_meat;
    pthread_mutex_unlock(&mutex(philo_num) && pthread_mutex_unlock(&mutex(philo_num - 1)
    return;




//// придумать проверку мониторинга смерти ;
//// как будет завершаться программа       ;
//// фукция потоками как используется      ;

Цикл по созданию потоков на четных и нечетных, где вызывается all
Функция all включает в себя бесконечный цикл, в котором содержаться действия:
- sleep
- eat
- death


2:07 pm

    i = 0;
    while(i < t.philo_num)
    {
        t.tred[i].left = &t.mutex[i];
        if(t.philo_num == 0)
            t.tred->right = &t.mutex[t.philo_num - 1];
        else
            t.tred[i].right = &t.mutex[i - 1];
        i++;
    }