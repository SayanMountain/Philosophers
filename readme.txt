Проект философы

Знакомит нас с процессами

Фишки, которые я узнал в ходе реализации проекта:
1 - Эльбрус лучше Intel за счет реализации многопроцессорности, а не торможения одного из как в архитектуре intel
2 - Можно с точки зрения алгоритмки ускорить выполнение кода, например, как при обработке времени

Команды:
    - для запуска
        make re && ./philo  5 600 200 200 5
                            4 310 200 100     должны погибать
                            5 800 200 200
                            4 800 200 200
                            1 800 200 200
                            201 800 200 200


    - для проверки количества приема пищи
        make re && ./philo  4 400 200 200 5 | grep "5 is eating"

    - для запуска бонусной части
        make bonus


Проверки:
    - выполнены

    - проверить:
        каждый философ должен поесть заданное количество раз
        header
            функции
            норминет
            мэйкфайл
                правила
            библиотеки

        ./philo 7 200 100 100

        на допустимые функции
        утечки
        норминет
        соотношение 5 философов и 5 вилок, не меньше не больше
        корректности отображения сообщений о статусах
            умер
            ест
            думает
            взял вилку
            принял пищу заданное количество раз






mutex = семафоры
tread = процессы

семафоры общие
8 = 8 и берут какие хотят вилки (4 берут 4 ждут)


Источники информации:

https://www.youtube.com/watch?v=2sv8LB0_uKg
Многопоточность нужна для:
1 - на примере программы из строки

? Современные процессоры имеют несколько ядер


- Запуск исполняемого файла активизирует выполнение процесса.
- Активация процесса запускает минимум 1 поток, и имеет одну точку входа
int main

Тут интересный переход
    Что можно сделать, чтобы ускорить работу нашего процесса?
    Ответ - запустить еще один поток


Что нам дает pthread?
    Это дает нам возможность запуска множества потоков

Как работает pthread_create?
    pthread_create(&t1, NULL, print, (void *)str1);
    где:
    t1 - указатель на идентификатор потока (проще поток)
    NULL - атрибуты
    print - запускаемая функция в потоке
    (void *)str1) - аргументы, которая функция принимает

Чем отличия от обычного исполнения кода?
    идет построково, код увидел функцию ушел в нее, завершил, вернулся в main
    когда мы используем многопоточность наш код не останавливается

Что необходимо использовать, дабы долждаться выполнения запущенного потока?
    pthread_join (t1, NULL)
    где:
    t1 указатель на идентификатор потока
    NULL - атрибуты
    Иными словами pthread_join является ограничителем, который не позволяет программе
    исполняться, до тех пор пока поток незавершен

Cоответсвенно, когда мы создали поток мы можем пойти лишь двумя способами:
    1 дождаться его завершения использовав pthread_join
    2 pthread_exit (выходит из какого-то потока сразу)


Как освободить ресурсы, которые задействоал поток?
    нужно использовать pthread_detach(t2);
    и запукать нужно внутри потока, чьи ресурсы требуется освободить


Тиакм образом, можно поток:
    - дождаться и завершить pthread_join
    - прекратить с высвобождением ресурсов pthread_detach

1 запрещены ли глобальные переменные?
2


!4 ВОПРОС Что такое mutex?
    mutex блокирует доступ к ресурсу другим потокам
    Обладает двумя состояниями (заблок и разблок)
    Это, по сути, наши вилки

    mutex надо накладывать на те участки кода, которые
    необходимо заблокировать после чего разблокировать


5 Deadlock
    дедлок ситуация, когда все философы схватили вилки вне очереди


6 Semaphor
    У каждого философа может быть свой семфор
    Может быть общий семафор на всех философов, который говорит, что можно ли есть или нет
    Если какой-то философов умер, то семафор останавливается и все вслед за ним (вошли в ожидание)
    После этого надо сделать kill


- мы не контролируем скорость запуска потока
- мы создали и запускаем потоки по очереди
- через ulseep (мы будем реализовывать, сколько он будет есть, пить и пр)
  надо модифицировать
-

Создаю массив из философов
Придаю их структуре порядок


if (philo_num % 2 == 0)
{
    pthread_mutex_lock(&mutex(philo_num) && pthread_mutex_lock(&mutex(philo_num - 1)
    eat_meat;
    pthread_mutex_unlock(&mutex(philo_num) && pthread_mutex_unlock(&mutex(philo_num - 1)
}
else
    pthread_mutex_lock(&mutex(philo_num) && pthread_mutex_lock(&mutex(philo_num - 1)
    eat_meat;
    pthread_mutex_unlock(&mutex(philo_num) && pthread_mutex_unlock(&mutex(philo_num - 1)
    return;




//// придумать проверку мониторинга смерти ;
//// как будет завершаться программа       ;
//// фукция потоками как используется      ;

Цикл по созданию потоков на четных и нечетных, где вызывается all
Функция all включает в себя бесконечный цикл, в котором содержаться действия:
- sleep
- eat
- death


2:07 pm

    i = 0;
    while(i < t.philo_num)
    {
        t.tred[i].left = &t.mutex[i];
        if(t.philo_num == 0)
            t.tred->right = &t.mutex[t.philo_num - 1];
        else
            t.tred[i].right = &t.mutex[i - 1];
        i++;
    }



    продумать смерть
    прием пищи в отдельную функцию + печать сообщения
    прием сна после пищи тоже в отдельную функцию + печать сообщения
    смерть: поток или функция, которая проверяет время по отношению к аргументу + проверка на смерть заменит цикл


    Владимир
    1 mutex на печать (любого действия) lock .. unlock



    Мне нужно отобразить сообщение о следующих действиях:
    - сон
    - еда
    - статус(если умер)
    - думать? (пока не умрет) флаги
    - наелся? (обдумать) флаги




    //// считать когда постоянно поел и поспал и не больше ли это время заданных аргументов
    //// detuch если какой-то философ умрет ()
    //// mutex_destroy когда они не нужны - признак когда кто то умер как и detuch
    //// 5 аргумент (количество приемов пищи * поставить счетчик на их прием и detuch-y и destoy-ю

    //// нужно ли sleep после каждой проверки???

    Парсер на следующие проверки:
    проверка на отрицательное количество философов (от 1-го)
    время еды от 0, сна от 0 или больше, чем время жизни, жизни больше 1. Умирают при загрузке системы 5 800 200 200

    Вписать из структуры данные, чтобы не вставлять везде 200 и пр


    Денис знает как через мэйк дебажить и ловить трэйсы и что такое     kill(-1, SIGKILL);





    	while (1)
    	{
    		pthread_mutex_lock(t->left);
    		pthread_mutex_lock(t->right);
    		printf("Time: %lu  Philo %d взял вилку\n", get_time() - t->last_eat, t->philo_id);
    		t->last_eat = get_time();
    		my_sleep(200); /// поел
    		pthread_mutex_unlock(t->left);
    		pthread_mutex_unlock(t->right);
    		eat(t->philo_id, get_time() - t->last_eat);
    		night(t->philo_id, get_time() - t->last_eat);
    		my_sleep(200);
    		thinking(t->philo_id, get_time() - t->last_eat);
    	}
    }



void    eat()
{
    pthread_mutex_lock(t->left);
    pthread_mutex_lock(t->right);
    t->table->current_time = get_time();
    printf("Time: %lu  Philo %d is taken fork\n", get_time() - t->table->start_time, t->philo_id);
    pthread_mutex_lock(&t->message);
    printf("Time: %lu  Philo %d is eating\n", get_time() - t->table->start_time, t->philo_id);
    pthread_mutex_unlock(&t->message);
    t->last_eat = get_time() - t->start_time;
    my_sleep(t->table->philo_eat);
    pthread_mutex_unlock(t->left);
    pthread_mutex_unlock(t->right);
}